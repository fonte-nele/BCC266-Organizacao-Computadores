Precisamos executar um conjunto de instruções numa maquina hipótetica. Neste caso simulando um computador simples, que executa uma determinada quantidade de 
instruções com o objetivo de somar, multiplicar, subtrair e dividir números de um vetor.

Para a resolução desse problema, foi utilizada uma máquina com as seguintes 
abstrações:

Uma variável MAX, que determina, a quantidade de instruções que o programa irá executar e o tamanho dos vetores de instruções e de dados.

TCache1 e TCache2,
 que definem o tamanho das respectivas cache

cacheHitN1, cacheHitN2, cacheMissN1 e cacheMissN2, que são usados para verificar o uso da cache.

Foi criada uma estrutura 
Topcode, que contem os seguintes campos: pos1,pos2, que definem as posições dos elementos, e oper, que define qual operação o programa irá executar.

Temos também a 
variável pc, que fica responsável pela contagem de quantas operações foram executadas, e a IR que esta sendo inicializada com -1 para que durante a verificação de 
enquanto o valor de IR for diferente de 4, na primeira execução do programa essa afirmação seja verdadeira.

Temos registradores, mq, mbr, mbr1 que serão usados na 
parte dos calculos do programa.

no inicio do desenvolvimento do trabalho, foram definidos quais seriam os passos executados pelo programa, gerando a seguinte lista 
de opcode:
		0-subtrai
		1-soma
		2-divide
		3-multiplica
		4-termina

com isso em mãos, seguiu-se para as 
definições de variáveis, prezando pela simplicidade do programa.

Em seguida, foi construido a sequencia de passos, utilizando for e switch, como será melhor detalhado 
a seguir.

============================================================================================================================

#define MAX 1000
#define tCache1 8

#define tCache2 16

float memoriaDados[MAX]

int cacheHitN1=0;
int cacheHitN2=0;
int cacheMissN1=0;
int cacheMissN2=0;

typedef struct opcode
{
	int pos1;
	int pos2;
	
int oper;
}Topcode;

vector<opcode> c1;
vector<opcode> c2;

Nessa parte do código estão declaradas as variáveis que serão utilizadas durante o decorrer da execução.


Primeiramente está sendo definido os parâmetros de execução do programa, em MAX como o vetor que será usado para definir o tamanho da memória de dados e de instruções, 
e também a quantidade de repetições que o programa irá executar.

Na declaração da memoriaDados se utiliza esse valor MAX para definir o tamanho do vetor, que será 
preenchido posteriormente.

Em seguida são declarados e inicializados os contadores de uso da cache cacheHitN1, cacheHitN2, cacheMissN1, cacheMissN2, onde seu uso 
será explicado posteriormente.

Foi declarada também um tipo Topcode, que será usado para montar o vetor de instruções.

A cache c1 e c2 foram declaradas como 
classe vector, para já poderem ser utilizadas.
=================================================================================================================================


int i, pc=0, IR=-1
float mq,
 mbr=0, mbr1=0;

Topcode* memoriaInst;
memoriaInst= (Topcode*)calloc(MAX,sizeof(Topcode));
preencherMemorias(memoriaInst);
numaleatorio();

Dentro do int main, está sendo
 declarada a variável i, que será utilizada no for, pc já sendo declarada e inicializada com 0 para contagem de quantas vezes os calculos foram executados, IR sendo
 declarada e inicializada com -1 para que sempre na primeira execução do programa, a verificação, se seu valor for diferente de 4 seja verdadeira.

Utilizando a 
estrutura Topcode está sendo declarado o vetor de instruções. Que em seguida, será alocado dinamicamente de acordo com o valor que foi definido em MAX.

Em seguida 
esse vetor é enviado para a instrução preencherMemorias para receber as informações necessárias
.

==================================================================================================================================


void preencherMemorias(Topcode* code)
{
	int i;
	for(i=0;i<MAX;i++)
	{
		if(i<=(MAX-2))
		{
			cin>>code[i].oper;

			cin>>code[i].pos1;
			cin>>code[i].pos2;
		}
		else
		code[i].oper=4;
	}
}

E a função 
numaleatorio, irá preencher o vetor de dados.

void numaleatorio()
{
	int i;
	srand(time(NULL));
	
	for(i=0;i<MAX;i++)
	
{
		memoriaDados[i]=rand()%100;
	}

	for(i=0;i<MAX;i++)
	{
		cout<<memoriaDados[i]<<endl;
	}
}

Em seguida, após o vetor ter 
sido preenchido, o mesmo é exibido na tela para o usuário.

While(IR!=4)
{
	opcode op = MMU_acessoAssociativo(memoriaInst[pc]);
	mbr=memoriaDados[op.pos1];

	mbr1=memoriaDados[op.pos2];
	IR=op.oper;
	Swicth(IR)
	{
		case 0:
			mq=mbr1-mbr;
			
cout<<mbr1<<" - "<<mbr<<" = "<<mq<<endl;
			break;
		case 1:
			mq=mbr1+mbr;
			cout<<mbr1<<" + "<<mbr<<" = "<<mq<<endl;

			break;
		case 2:
			mq=mbr1/mbr;
			cout<<mbr1<<" / "<<mbr<<" = "<<mq<<endl;
			break;
		
case 3:
			mq=mbr1*mbr;
			cout<<mbr1<<" * "<<mbr<<" = "<<mq<<endl;
			break;
	}
	pc++;
}

Então chegamos na parte mais 
importante do código, dentro desse while, a função MMU_acessoAssociativo recebe a memória de instruções com o indice com o valor registrado em pc, que retorna as 
informações para o vector opcode op, que são repassadas para mbr, mbr1 e IR, sendo que o valor recebido de op.pos1 e op.pos2 são repassadas para mbr,mbr1 e IR, 
sendo que o valor recebido de op.pos1 e op.pos2 são utilizados como indice para o vetor de dados, que então são repassados para as variáveis mbr e mbr1.

E IR apenas 
recebe o valor de op.oper.

que então cai no switch com o valor de IR, para então fazer o respectivo calculo.

opcode MMU_acessoAssociativo(opcode inst)


========================================================================================================================================


int here=0;
int i=0;

if(c1.push_back(inst))
{
	c1.push_back(inst);
	c2.push_back(inst);
	cacheMissN1++;
	cacheMissN2++;
	return c1.at(c1.size()-1);
}

else
{
	for(i=0;i<tCache1;i++)
	{
		if(c1.at(i).oper==inst.oper && c1.at(i).pos1==instpos1 && c1.at(i).pos2==inst.pos2)
		
{
			cacheHitN1++;
			here=1;
			break;
		}
		if(here)
			return c1.at(i);

		else
		{
			cacheMissN1++;
			if(c2.size()<tCache2)
			
{
				cacheMissN2++;
				c2.push_back(inst);
				return c2.at(c2.size()-1);
			}

			else
			{
				here=0;
				for(i=0;i<tCache2;i++)
				
{
					if(c2.at(i).oper==inst.oper && c2at(i).pos1==inst.pos1 && c2.at(i).pos2==inst.pos2)
					
{
						cacheHitN2++;
						here=1;
						break;
					}

					if(here)
						return 0;
					else
					
{
						cacheHitN1++;
						cacheHitN2++;
						
c2.pop_back();
						c1.pop_back();
						c1.push_back(inst);
						
c1.push_back(inst);
						return c1.at(c1.size()-1)
					}
				
}
			}
		}
	}

Nessa parte do código é onde acontece a cache. É inicializada a variável 'here' com zero e o i que será usado no for também.


No primeiro if, ele verifica se tem espaço na cache, se tiver, a instrução é armazenada na cache1 e cache2, e incrementa. 
E em seguida retorna essa instrução

Caso contrário entra no else, que irá verificar cada item da cache, comparando o que foi recebido com o que esta armazenado, 
se encontrar, ele ativa com 1 a variavel 'here', e incrementa 1 na cache hit 1.

que logo em seguida um if verifica se here esta com o valor 1, se estiver, ele 
retorna a instrução encontrada. Caso contrário ele passa para a cache 2, e faz a mesma verificação, se tiver espaço livre, ele adiciona a instrução e a retorna,
 após incrementar o cache miss 2.

Continua com a mesma verificação, se encontrar a instrução na cache 2, LIFO ele vai retirar a ultima instrução das caches, e vai
 adicionar a que ele recebeu nas duas, inscrementar o cache hit 1 e 2 e retornar essa instrução.


cout<<"\nCache Hit: \n Cache1: "<<cacheHitN1<<"\nCache 2: "<<cacheHitN2<<endl;
cout<<"\nCache Miss: \n Cache1: "<<cacheMissN1<<"\nCache 2: "<<cacheMissN2<<endl;


free(memoriaInst);

Após terminar os calculos, antes de finalizar o programa , é exibido a contagem de cache hit e cache miss de cada cache.

Para então liberar a 
memória que foi utilizada no vetor de instruções.

